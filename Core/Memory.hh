#pragma once

namespace core
{
	enum MemoryAllocator : int
	{
		CORE_MEMORY_ALLOC_UNDEFINED = -1,
		CORE_MEMORY_ALLOC_DEFAULT = 0,
		CORE_MEMORY_ALLOC_TEMP,
		CORE_MEMORY_ALLOC_CONTROLLER,
		CORE_MEMORY_ALLOC_SCRIPT_POOL,
		CORE_MEMORY_ALLOC_SCRIPT_FUNC,
		CORE_MEMORY_ALLOC_SCRIPT_CODE,
		CORE_MEMORY_ALLOC_SOUND,
		CORE_MEMORY_ALLOC_FRONT_END,
		CORE_MEMORY_ALLOC_RENDERING,
		CORE_MEMORY_ALLOC_GAME_OBJECT,
		CORE_MEMORY_ALLOC_CHARACTER,
		CORE_MEMORY_ALLOC_PATH,
		CORE_MEMORY_ALLOC_COLLISION,
		CORE_MEMORY_ALLOC_VEHICLE,
		CORE_MEMORY_ALLOC_STATE_PROP_RUNTIME,
		CORE_MEMORY_ALLOC_RESOURCE,
		CORE_MEMORY_ALLOC_SCRATCH,
		CORE_MEMORY_ALLOC_MINFO,
		CORE_MEMORY_ALLOC_DEBUG,
		CORE_MEMORY_ALLOC_DEBUG_COMM,
		CORE_MEMORY_ALLOC_DEBUG_RENDERING,
		CORE_MEMORY_ALLOC_DEBUG_32,
		CORE_MEMORY_ALLOC_FE_REDIRECT,
		CORE_MEMORY_ALLOC_FRONT_END_TEMP,
		CORE_MEMORY_ALLOC_CACHE,
		CORE_MEMORY_ALLOCATOR_MAX = 0x7F
	};

	class IMemoryAllocator
	{
	public:
	};

	//=========================================================
	// Functions

	template <typename T>
	SR_INLINE T* New(size_t p_Size)
	{
		return reinterpret_cast<T*(__cdecl*)(MemoryAllocator, size_t)>(0x6DC390)(CORE_MEMORY_ALLOC_DEFAULT, p_Size);
	}

	template <typename T>
	SR_INLINE T* New()
	{
		return New<T>(sizeof(T));
	}

	SR_INLINE void Delete(void* p_Block)
	{
		reinterpret_cast<void(__cdecl*)(MemoryAllocator, void*)>(0x43CE70)(CORE_MEMORY_ALLOC_DEFAULT, p_Block);
	}
}